https://www.youtube.com/watch?v=pvS3xRTdX90&list=PLdPwRNmUlk0lw0nkFgbqwuFHyprkCT0qz&index=4
some key features and concepts of react include
components react allow to devloper to create reusable ui components which encapsulate their own logic and state
jsx javascript xml is an  extension to javascript used 
react it enables devlopers to write html like syntac within javascript making it easier to describe and reder componetns
virutal dom: react uses a virtual representation of the dom which is a lightwieght copy of the acutal
html dom. it  allows react to efficiently update
and render only the ncessary components when the application state changes

some key features and concepts of react include
unidirectional data flow: it follows a undirectional data flow als know as one way binding. it means 
data in react application flows in a single direction
from parent to components to child components.
this help to main a predictable state and make it easier to debug and understandd the application

react hooks:
introduced in react 16, hooks are function that allow developoers to use state and other react features in functional components, instead oif relying on class components hook provide a simpler and more concise way 
of managing state and lifecycle events

react has vast ecosystem and tools that complements capabilities it oftern used in combination with 
oither technologies such as redux for stat managament react router for routing and axios for making api 
request

react version react 0.3 may 2013
made public 

react jss enivronemnt setup
https://github.com/coreybutler/nvm-windows/releases
nvm setup for multi version node nvm list to check
for installing old version node
nvm install 18.16.0
then use nvm list-> nvm use 18.16.0
npm i or install  -> to check it file avaiable for checking update
to uninstall package
npm uinstall react-validation  (copy from package.json)

react js function components
it is one of the core building blocks of reacts
made of pieces of components
types of components
functional component
clss components
pure component
high order components
controlled components
uncontrolled components

export const User = () => {
  return (
    <div>User Sam Bajracharay</div>
  )
}
use import {user} fom './user'; when need to call mulitple function

react js class components part 7
it bread and butter fo most modern web apps. these components are
siple clsses made up of multiple functions that add functionality to the
application. all class based components are child clsses for the 
components class of react js
rce then tab

function Common(){
  return <div>common compontns</div>
}
to use function use  {common()} , use curly bracket
or <Common/>

react js with jsx javascipt extension

react js click event and function
event handler determine what action is to be taken whenver
an event is firest. this could be a button click or change in a text input
<button onClick = {hello()}> hello </button>
parenthesis shouldnt be used.otherwise it will automatically trigger
<buton onClick ={demo}>Cclick me</buton>
 <button onClick = {()=>alert("hello")}>click me</button>
 <button onClick = {()=>demo()}>click me</button>

 react js state and function
 it is an updatable structure that is used to contain data or 
 information about the components.the state in a component can change
 over time.it determine behaviour of the components and how it
 will render. they are also responsible for making a components
 dynamic and interactive
 a state must be kept as simple as possible .it can be set by using
 the setstate() method and calling setstate() method triggers
 ui updates. to set an initial state before any interaction occurs
we need to use the getinitialState() method
useState
import { useState } from 'react';
  let [data, setData] = useState("sam bajracharay");
  sam bajrcharay store in Data

  setData function trigger 
  function Counter(){
    const [count, setCount] = useState(0);
    const increment =()=>{
        setCount(count + 1);
    }
    return(
        <div>
            <p>Count: {count}</p>
            <button onClick={increment}>Count</button>
        </div>
    )
}

React js state class components
import React, { Component } from 'react'
import "./App.css";
class App extends Component {
constructor(){
  super();
  this.state ={
   data: 1,
  };
}
demo(){
  // alert("class components");
  this.setState(
    // {data: "sam bajracharya",}
   { data: this.state.data + 1,}
  );
}
render(){
  console.log(this.state.data);
  return (
    <>
    <h1>{this.state.data}</h1>
    <button onClick={()=>this.demo()}>click me</button>
    </>
  )
}
}

export default App


react js props function components.
pops stand for properties they are read only components
it is an object which store the values of attributes of a tag
and work similar to the html attributes.
props are immutable so cannot modify the props from inside the components

we can dd attributers called props. these attributes are 
available in the components as this.props and can be used to render
dynamic data in our render method.
const App = () => {
  const [name, setName] = useState("sam bajracharya");
  // const userData = [
  //   {name:'sam', age: 25, email: 'sam@gal.com'},
  //   {name:'sam2', age: 75, email: 'sam@wgal.com'},
  //   {name:'sam3',age: 15, email: 'sam@ggal.com'}
  //   ];
  return (
<>
{/* {userData.map((user,index)=>(
<UserCard
key = {index}
name ={user.name}
age = {user.age}
email = {user.email}
/>
))} */}
<UserCard name={name} />
<button onClick={()=> setName("hero honda")}>Update Name</button>
</>

  )
}
export default function UserCard(props2) {
  // const {name,age,email} = props2;
  return (
<>
{/* <h1>hello world {props.name}</h1> */}
{/* <p>{name}</p>
<p>{age}</p>
<p>{email}</p> */}
</>
  )
} rfc for default export function
rcc shortcut for components

React Props With Class Component
usercard.jsx
import React from 'react'

export default function UserCard(props2) {
  // const {name,age,email} = props2;
  return (
<>
{/* <h1>hello world {props.name}</h1> */}
{/* <p>{name}</p>
<p>{age}</p>
<p>{email}</p> */}
</>
  )
}
//
app.jsx
import React, { Component } from 'react'
import './App.css';
import UserList from './UserList';

export default class App extends Component {
constructor(){
  super();
  this.state ={
    name: "hoer honda"
  }
}
 
  render() {
    return (
      <>
      <div className="App">
        <h1>Props in React</h1>
        {/* <UserList name="sam bajracharya"
        email ="szm@gmail.com"
        /> */}
       <UserList name={this.state.name}
        email ="szm@gmail.com"
        />
        <button onClick={()=>this.setState({name:"dio"})}>Update Props</button>
      </div>
      </>
    )
  }
}

Reactjs get input box value (without form)
the onChange event handler is a prop that you can pass into jsx
<input> lements. this props is provided by react so that your
application can listen to user inout in rel time when an onChange
even occurs. the prop will call the function you passed as its parameter
function handleChange(event){
  console.log(event.target.value)
}
<input onChange ={handleChange} />

--
import React, { useState } from 'react'
import "./App.css";

const App = () => {
  const [inputValue, SetInputValue] = useState("");
  const [inputValueShow, setinputValueHide] = useState(false);

  const handleChange = (event) => {
    console.log(event.target.value);
    SetInputValue(event.target.value);
    //remove submit value
    setinputValueHide(false);
  }
  return (
  <div className="App">
    {/* <h1>{inputValue}</h1> */}
    <h1>{inputValueShow ? inputValue :''}</h1>
    <input type="text" onChange={handleChange} />
    <button onClick={()=>{setinputValueHide(true)}}>show me</button>
  </div>
  )
}

export default App


 React Hide Show & Toggle
 const App = () => {
  const [status, setStatus] = useState(true);
  return (
    <div className="App">
      <h1>SHow and hide</h1>
      {status ? <div className="status">Content</div>: null}
      <button onClick={()=>setStatus(false)}>Hide</button>
      <button onClick={()=>setStatus(true)}>Show</button>
      <button onClick={()=>setStatus(!status)}>Toggle</button>
    </div>
  )
}
react js form handling
import React,{useState} from 'react'

export default function FormHandling() {
    const [formData, setFormData] = useState(
{
username:'',
email:'',
password:'',
isSubscribed:'',
role:''

} );
const handleChange = (event) => {
    const {name, value, type, checked} = event.target;
    const fieldValue = type === 'checkbox' ? checked : value;

    setFormData({
        ...formData,
        [name]:fieldValue
    });
}
const handleSubmit = (event) => {
    event.preventDefault();
    console.log('Form Data', formData);
}
  return (
   <>
   <form onSubmit={handleSubmit}>
    <div>
        <label htmlFor="username">username:</label>
        <input type="text" name="username" 
        id="username"
        value={formData.username}
        onChange={handleChange}
        />
    </div>
    <div>
        <label htmlFor="email">Email:</label>
        <input type="email" name="email" 
        id="email"
        value={formData.email}
        onChange={handleChange}
        />
    </div>
    <div>
        <label htmlFor="password">Password:</label>
        <input type="password" name="password" 
        id="password"
        value={formData.password}
        onChange={handleChange}
        />
    </div>
    <div>
        <label htmlFor="isSubscribe">Subscribe:</label>
        <input type="checkbox" name="isSubscribed" 
        id="isSubscribed"
        value={formData.isSubscribed}
        onChange={handleChange}
        />
    </div>
    <div>
        <label htmlFor="role">Role:</label>
    <select name="role" id="role" 
    value={formData.role}
        onChange={handleChange}>
    <option value="">Select Role</option>
    <option value="admin">admin</option>
    <option value="user">user</option>
    <option value="guest">Guest</option>
    </select>
    </div>
    <button type="submit">Submit</button>
   </form>
   </>
  )
}

react js conditional rendering
conditional rendering in rect allows you to show or hide
component based on certain conditions. it is a powerful features
that helps you create dynamic and interactive user interfaces
export default function Profile() {
    const isLoggedIn = true;
    const items = ["apple", "banana","orange"];
    const isAuthenticated = true;
    
  return (
   <>
 {/* {isLoggedIn ? <h2>Welcome User</h2>: <h2>Welcome Guest</h2>} */}
{
items.length > 0 ? (
    <ul>
        {
          items.map((item, index)=>
            <li key={index}>{item}</li>
          )  
        }
    </ul>
) : (
    <p>No items to display</p>
)
}
<div>{isAuthenticated && (
    <button onClick={()=>{console.log("log out");}}>Logout</button>
)}</div>
   </>
  )

  React Js form validation
it refers to the process fo validating user input within a form to ensure that it meets
certain criteria or constraints before it is submitted , it help in preventing User from
submiiting incorrect or incomplete data and provides a better user experience by giving feedback
on the input errors
import React, {useState} from 'react'

export default function FormValidation() {
const [name, setName] = useState("");
const [email, setEmail] = useState("");
const [password, setPassword] = useState("");
const [errors, setErrors] = useState({});
const [submittedData, SetSubmittedData] = useState(null);
const validateForm = () =>{
let isValid = true;
const newErrors = {};
if (!name.trim()){
newErrors.name = "Name is required";
isValid = false;
}
if (!email.trim()){
    newErrors.email = "Email is required";
    isValid = false;
    }else if(!/\S+@\S+\.\S+/.test(email)){
newsErrors.email = "Email is invalid";
isValid = false;
    }
    if (!password.trim()){
        newErrors.password = "Password is required";
        isValid = false;
        }else if(password.length < 6){
newsErrors.password
 ="password should be more than 6"
        }
setErrors(newErrors);
return isValid;
}
const handleSubmit = (event) => {
event.preventDefault();
if(validateForm()){
const submittedDate = {
    name, email, password
};
SetSubmittedData(submittedData);
console.log("form submited", submittedData);
}

}
  return (
    <>
    <form onSubmit={handleSubmit}>
       <div>
        <label>Name:</label>
        <input type="text" name="" id="" value={name} onChange={(e)=>setName(e.target.value)} />
        {errors.name && <span className="error">{errors.name}</span>}
       </div>
       <div>
        <label>Email:</label>
        <input type="email" name="" id="" value={email} onChange={(e)=>setEmail(e.target.value)} />
        {errors.email && <span className="error">{errors.email}</span>}
       </div>
       <div>
        <label>password:</label>
        <input type="password" name="" id="" value={password} onChange={(e)=>setPassword(e.target.value)} />
        {errors.password && <span className="error">{errors.password}</span>}
       </div>
<button type="submit">Submit</button>
    </form>
    {
submittedData && (
    <div>
        <h2>Submitted Data</h2>
        <p>Name: {submittedData.name}</p>
        <p>Email: {submittedData.email}</p>
        <p>Password: {submittedData.password}</p>
    </div>
) }
    </>
  )
}

React Js Pass Function as Props
you can pass function as props to child components. this allow you to 
communicate and share functionality between different parts fo your application
import React from 'react'

export default function Users(props) {
    console.log(props);
   
  return (
   <>
   <h1>Users</h1>
   <button onClick={props.handleClick}>click em</button>
   <p>Count {props.count}</p>
   <button onClick={props.increment}>Increment</button>
   </>
  )
}
import React, {useState} from 'react'
import './App.css';
import Users from './Users';


const App = () => {
  const handleButtonClick = () => console.log("button clicked");
  const [count, SetCount] = useState(0);
  const incrementCount = () => {
    SetCount(count + 1);
  }
  return (
    <div className="App">
  <h1>React pass function</h1>
  <Users handleClick = {handleButtonClick}
  count = {count} increment = {incrementCount}
  />

    </div>
  )
}

export default App

Life Cycle Methods
it refers to a set of functions that are invoked at various stages of a components
life cycle.these methods allow you to perform specific task or execute code
at different points during the components existence
in prvious versions of react, there were several life cycle methods available but with the
introduction of react 16.3 and later some of these methods have been deprected in favor of
a new set of methods based on the concept of react hooks however the older life cycle methods
are still supported and can be used in existing codebases.
3phases mounting, updating, unmounting //https://www.youtube.com/watch?v=4vJC5wKhvyI&list=PLdPwRNmUlk0lw0nkFgbqwuFHyprkCT0qz&index=20

the main life cycle methods in react
mounting phase
constructor():
this method is called when a components is being initialized and constructed.it is typically
used for initializing state and binding event handlers
static getDerivedStateFromProps() this method is invoked before rendering both on the inital mounting
and on subsequent updates.it allows you to update the state based on changes in props
render():
this method is responsible for rendering the components jsx markup
componentDidMount(). this method is called immediately after the components has been mounted
to the dom. it is commonly used to initiate api calls or set up event listeners

updating phase:
static getDerivedStateFromProps()/ as mentioned earlier this method is also called during the 
updating phase when new props are received

shouldcomponentUpdate(): This method determines whether the component should re render or not
it can be used to optimize performance by avoiding unnecessary re-renders

render(). the render method is called again to update the component's ui
getSnapShotBeforeUpdate(). this method is called right before changes are committed to the dom
it allows you to capture information from the dom before it is potentially changed

componentsDidUpdate(): this method is invoked after the component has been re-rendered and the
changes have been applied to the dom.it is often used for side effects such as updating the dom
based on prop or state changes

unmounting phase
componentwillunmount()
this method is called right before the components is removed from the dom .it can be used
to perform cleanup task like removing event listeners or cancelling api requests.

when it calls the lifecycle method in react
when component is loaded
when components is updated wih state and props
when components is removed


react js constructor lifecycle

the constructor method is part of the components life cycle and is invoked during the 
mounting phase. the constructor is a special method that gets called when an instance
of a component is created

purpose
the constructor method is primarly used for initializing the components state and binding event
handlers.
it is also used to set up the initial values or state based on components props
the construcotr is called before the component is mounted to the dom
in a class based component the constructor method is defined within the component class
the constructor take a props parameter which is optional it should be passed to the super() metod to
call the constuctor of the parent class(usually component).
the state can be initialized within the constructor by assigning an object to this.state
class App extends Component {
constructor(){
  super();
  console.log("constrcutor methiod");
}

  render(){
    console.log("render methiod");
  return (
    <div>Life Cycle Method</div>
  )
}}

reactjs render lifecycle
it is the techniue tht can redirect a page with the help of function render(). most importantly
render a function we can use to define the html code within the html elements it helps to display
certin views in the ui using certain logic defined in the render  function and returns the output

purpose
react renders html to the wb page by using a function called render()
the purpose of the function is to display the specified html code inside the specified html elements
in the render() method, we can read props and state and return our jsx code to the root components
of our app.
in the render () method we cannto change the state and we cannot cause side effect(such as making
an http request to the webserver)
//rendermethod.jsx
import RenderMethod from './RenderMethod';
const App = () => {
  // const [name, setName] = useState("sam bajracharay");
  return (
   <div className="App">
    {/* <RenderMethod name={name}/> */}
    {/* <button onClick={()=>setName("Bajracharay")}>Update Name</button> */}
    <RenderMethod />
   </div>
  )
}

reactjs 
componentDidMount
method is a life cycle method that is invoked immediately after a component has
been mounted to the dom. it is a good place to perform initializations, side effects
or interact with external apis
purpose
making api call to fetch data from server
setting up event listeners or subscriptions
manipulating the dom or interacting with external libraries
performing additional initialization or setup tasks.

import React,{Component} from 'react'
import './App.css';

class App extends Component {
constructor(){
  super();
  this.state = {
count:0,

  };
  console.log("constructor called");
}
incrementCount = () =>{
this.setState((prevState)=>({
  count:prevState.count + 1,
}))
}

componentDidMount(){
  console.log("constructor22 called");
}
render(){
  console.log("render");
  return (
    <>
    <div className="App">
    <h1>Lifecycle component did mount</h1>
    <h2>Count:{this.state.count}</h2>
    <button onClick={this.incrementCount}>Increment</button>
    </div>
    </>
      )
}
}

export default App


componentDidUpdate 
this method allow us to execute the react code when the component is updated all the network request that are to be made when the props passed to the
component changes are coded however
purpose
handle side effect and perform additional operations after  component update
respond to changes in props or state
update the dom or interact with external libraries after a component update
perform asynchronous operations based on prop or state changes
optimize performance by avoiding unncessary updates or expensive calculations.

react shouldcomponentupdate
in react should component update is a lifecycle mehtod avaiable in class components. its purpose is to optimize rendering 
performance by allowing you to control when a component should updat and re-render.
by default, when a component sate or props change, react re-renders that components to reflect the changes. however rerendering
can be an expensive operation especially for complex  components or components trees. in some cases, rendering may be unnecessary
if the new state or orps do not affect the components output. this is where shouldcomponentUpdate becomes valuable

purpose
your implementation of shouldcomponentUpdate should return a boolean value. 
if it return true, the component will re-render as usual. if it returns falsem, the components will not rerender even if the props
or state have changed

react js componentwillunmount
it was a lifecycle method used in class components, however it is important to note that as of react 17, this method has been
deprecated and is no longer recommended for use react introduced the unmounting phase where components are removed from the dom
and componentwillunmount used to be a part of this phase.
the componentwillunmount method was invoked right before a component was removed from the dom and destroyed. it provided an
opportunity to perofrm any necessary cleanup taks, such as cancelling timers, clearing subscriptionss, or releasing resources
to avoid memory leaks.
purpose
it is called just beore a component is removed from the dom and destroyed.
its primary purpose was to avoid memory leaks by cleaning, up resources associated with the components.
with the introduction of react hooks and the useeffect hook, cleanup taks can be handled more easily and efficiently in
functional components.

//react js hooks lifecycle  // life cycle update
function that allow you to use state and other react features in functional components whihc were traditionally stateless.
hooks were introduced in react version 16.8 to provide a ore elegant and reusable way to manage state and lifecycle behaviors
in functional components.

before hooks, react components were mainly created using class components. which allowed the use of lifecycle methods and state
however class components can become cumbersome and harder to maintain as the components logic grows hooks provide an 
alternative way to write components in a more concise and readable manner.
list of hooks
usecallback
usecontext
usedebugvalue
usereducer
useeffect
useState
useRef
UselmperativeHandle
useLayoutEffect
useMemo
useSyncExternalStore
useTransition
useInsertionEffect
useDeferredValue
useId

what is useEffect Hook?
it is a built in hook that allows you to perform side effects in functional components. side effects typically involve tasks
that should be executed after the component hs rendered, such as fetching data from an api, subscribing to event listeners, or
updating the document title. it is analogous to lifecycle methods like componentDidMount, componentDidUpdate and componentwillunmount
in class components.
useEffect(()=>{
  side effect code here
  this code will run after every render
  it may perform any cleanup if needed
  return()=>{
    thsi code will run when the component is unmounted or before the next render
  }
}, []);
useeffect, render everytime , updating, it will run everytime

useffect with condition

styles for react components
react is a jas library for building user interfaces. react makes it painless to create interactive  Uis. Design simple views for each state in your application and react will efficiently
update and render just the righ component when your data changes.
there are different ways to styling react js components
inline css, normal css, css in js, css module, sass and scss , styled components(external package)
//boostrap installation

array with map
it a fundamental data structure in computer programming that represent a collection of elements stored in contiguous block of memory.
these elements can be of the same or different data types such as number, strings, objects, or even other arrays, arrays are commonly used
to organize and manipulate a group of related values.
in most programming languages, including javascript (used in react js) arrays are zero indexed which means the first element is accessed
with an index of 0 the second element with an index of 1 and so on.

array with map
arrays offer various methods and properties to manipulate and work with the data they store, such as map(), filter(), reduce(), length etc. these methods
allow developers to perform operations on the array elements easily and efficiently.

using map() over a traditional for loop in react js has several advantages the map() function provides a more concise and expressive way to perform
transformations an arrays and is often preferred for rendering list fo elements, here are some reasons why using map() is common in react js

declarative approach map() is a higher order function which means it follows a declarative programming paradigm, instead of explicity defining the iteration step you only describe what
you want to achieve. this make the code easier to read and understand

immutable operation: react encourages immutable data handling and map() inherently creates a new array with the transformed elements leaving the original array unchanged. this is
useful for avoiding side effects and making the application more predictable.

no need to manage index: when using map(), you dont have to manually manage the array index(as you would in a for loop) when rendering elements in react. the keyp prop automatically take
care of uniquely identifying each rendered component in the list.

cleaner code: using map() can result in more concise and cleaner coe. it reduces boilerplate and increase code readability.

react nest map
it refers to using the map function inside another map function. this approach is commonly used to handle
data that has multple levels of nesting such as an array or an array of objects that contain arrays

when you encounter nested data structures in react you can use nested mao function iterate through the data
at each level and render the corresponding ui components.

//what is fragments?
it a features that allows you to group multiple elements together without introducing an additional
wrapping elements in the dom. fragments are used to return mulitple elements from a components render
method adding unnecessary markup to the resulting html
before fragements were introduced in react devlopers often had to wrap mulitple elements
in  single container elements even if that container element didnt serve any semantic purpose other than
to group those elements together.
Good question! The use of Fragment in React can seem a bit redundant when you can use the shorthand syntax (<>...</>), but here are some reasons why Fragment import might still be useful:

Key Attribute Support: The shorthand (<>...</>) does not allow you to pass attributes. If you need to pass a key (e.g., when rendering a list of items where each fragment needs a unique key), you'll need to use <Fragment> explicitly.
import { Fragment } from "react";
const items = [1, 2, 3];
const list = items.map((item) => (
   <Fragment key={item}>
      <h1>Item {item}</h1>
      <p>Description for item {item}</p>
   </Fragment>
));

// react lifting state up
it is a design pattern used to manage shared state among mulitple component by moving the state from
a lower level component to higher level cmponent in the component tree.
this pattern is especially useful when two or more component need to share the same state or when
a child component needs to update the state of its parent or another sibling component.

how lifting state up works in react
identify the shared state: when you have two or more component that need access to the same
state or need to synchronize their data you can identify the common state that needs to be lifted up.

move the state up: instead of keeping the state in one of the child components, you move it to the parent
component that is an ancestor to all the component that require access to the state. this parent component
now becomes the single source of truth for the shared state.

pass the state down as props: after moving the state to the parent component, you pass it down to the child

components as props. this allows child components to read and use the state as needed.

modify the state through callbacks: to update the state from child components, you pass down callbacks
functions(also as props) fromt the parent, when a child component needs to change the state, it calls the
callback, and the parent components handles the state update. this way, the parent component controls
how the state is modified.

//pure components
it is a specific type of component that is designed to optimize performance by minimizing

unnecessary rendersin react component are re-rendered whenever their state or props change
however if a component render output is solely determined by its props and state, and they
have not changed there is no need to re-render the component. this is where pure component
come into play

pure comment in react is a class component that extends the react.purecomponent class or since
react 16.6 it can also be written as a functional component that utlilize the react.memo() high
order component .the main characteristic of a pure  component is that it automatically implements a
 shallow comparsion of props and state to decide whether to re-render or not.

 // react memo
 it is a higher order component used to optimize functional components by preventing unnecessary re-renders
 it is a performance optimization technique aimed at improving the efficiency of react applications.

 when a functional component is wrapped with react.memo, react will automatically memorize the component.
 memoization means that react will store the rendered output of the component and only re-render it when
 the component props have changed if the props remain the same, react will reuse the previously rendered
 output. avoiding the need to recalculate or re-render the component.

 //react useMemo Hook
 the usememo hook in react is used to memorize the result of acomputation
 and optimize the performance of functional component. its one of the built
 in hooks that react provides to hel us manage expensive calculation or data processing efficiently
 the basic purpose of usememo is to cache the return value fo a function and  only recompute it when the
 dependencies specified in the second argument of the useMemo call change. this behaviour prevents
 unnecessary recalculations and can significantly improve the performance of our components.

 //react ref (use for class components)
 Class Components: React.createRef is typically used in class components to create a ref.
 it is special attribute that can be used to access or reference a dom element or a react component
 instance.it provide a way to interact direclty with dom elements or components, enabling you to perform
 certain operations like focusing an input field accessing the dimensions of an element, or triggering
imperative animations.

//useRef
Functional Components: useRef is specifically designed for functional components introduced with React Hooks.
it is a hook that allows you to create a mutuable reference to an element or a value that persists across
renders. it is commonly used for accessing and interacting with dom elements. managing focus and storing
values that should not trigger a re-render when they change.

the primary use cases for useref
accessing dom elements: you can use useref to get a reference to a dom element and interact with the direclty
like changing its style, adding event listeners, or triggering imperative functions.

storing mutuable values: since the ref object persists across renders, you can use it to store values that
need to be accesses and updated without triggering re-renders.

caching exensive calculations: if you have a computation that is costly in terms of performance and doesnt
depend on the components state or props, you can useref to store the result of the computation and reuse
it across renders

//react forwardRef
it is a special function in react that allows you to forward a ref from a parent component to a child component.it is primarily used when you need to access
the dom element or component instance of the child component from its parent.
the primary use cases for forwardref are:
accessing dom elements: if you need to focus, scroll, or perform other dom related operations on a child
component, you can use forwardRef to get access to the child's dom elements.

exposing child components functions: you might have some functions in the child components that you
want to trigger from the parent component. using forwardRef, the parent component can call those functions
directly on the child component instance.
useImperativeHandle (when need to access function in parent via ref)

react controlled components
it is a component whose state is controlled entirely by the react component itself. the component
state is managed by react, and any changes to the components state are done through react setstate(0
) method. this allows react to have full control over the components behaviour and enables 
synchronization with the user interface control over the component's behaviour and enables synchronization
with the user interface.
the primary use cases for controlled component are:
state management. the components state is stored within the components itself using the useState or this.state
(for class components) hook. this state is used to determine the current value of the components.
props as input: controlled components receive their current value as a prop from their parent component. the 
parent component maintains the state, passwing it down to the controlled components as a prop.

what is controlled components?
event handling: any changes to the components value(eg user input) are captured through event handlers, such as
onChange, onClick etc.
updating state: when an event occurs (eg: user types in an input field), the event handler calls setState(or equivalent) to update
the components state with the new value.
re-rendering: when the state is updated, the components is re-rendered with the new  value, and the user interface reflects
the latest state.
single source of truth: the components value is solely derived from its state. so the state becomes the single source of truth
for the components value..


what is uncontrolled components
it is a component whose state is managed by the dom rather than being controlled by
react itself. unlike controlled components, where react handles the state and updates
uncontrolled components rely on the underlying dom to keep track of the components
state. this means that the state is not directly accessible through react's setState or useState mechanism

the primary use cases for uncontrolled components are:

no explicit state: uncontrolled components do not have an explicit state defined within the react components.
ref for access: instead of using state, you typically use a ref to access the current value of the components. ref
are a way to directly interact with the dom elements in react.

dom as source of truth: the components values is managed by the dom itself. for egL in an uncontrolled input components
the value is controlled by the value attribute of the html input elements.

event handling: event handlers are used to capture changes to the components value similar to controlled
components. event like onChange , onClick etc, are still utilized.

no re-renders: since there is no state being updated, changes to the components value wont trigger 
re-renders of the component. this can lead to potential inconsistencies between react's virtual dom and
the actual dom.

react higher order components
high order component(hoc) is a design pattern in react that involves wrapping a component with another function 
or component in order to enhance it behavior or provide additional props. this pattern is commonly used to reuse
component logic, hangle cross cutting concern, and make components more modular.
the primary use cased for hoc are:
reusable logic: hocs are design pattern in react used to share and reuse components logic across multiple components
function wrapper: a hoc is a function that takes a component and returns a new component with enhanced features or behaviour

composition: hocs enable component composition by wrapping one component with another to augment its functionality.

cross cutting concerns: they help manage cross cutting concerns like state management, authentication, logging and data fetching

props injection. hocs can inject addtional prop, sate or functions into the wrapped component.

modularity: by separating concerns.hocs make components more modular and focused on specific taks.

code reusability: common logic can be encapsulated in hocs reducing code duplication across components.

usecallback hooks ?
it in react is used to optimize the performance of your components by memoizing functions ensuring
that they are not recreated on every render.

the primary use cases for usecallback are:
function memoization: use callback memoizes  (caches) a function, ensuring that the same function
instance is returned on subsequent reners as long as it dependencies remain unchanged, this is 
particularly useful to prevent unnnecessary re-renders of child components that receive functions
as props.

dependencies array: the second argument to usecallback is an arry of dependencies.if any of these dependencies change
between renders, the memoized function will be recreated; otherwise, it will return the previously memoized function. make
sure to list all variables that the functions relies on.

useCase - event handlers: when passing event handlers to child components, using usecallback prevents those handlers from
being recreated on each render. this helps avoid unnecessary re-renders of child components as they wont treat the functions
as new prop ech time the parent re-renders.

performance optimization: without usecallback each render of a  component that uses a funcion without memoization
would crete a new function instance, this can lead to increased memory usage and potential performance bottlenecks.

usage with useeffect: when using useeffect, its important to include any function from the components scope that are  used 
inside the effect in the dependencies array. using callback in conjuction with useeffect can ensure that effects are only re-run
when necessary.

caveats: while usecallback can help optimize performance. its important not to overuse  it. not eery functions needs to be
memoized. overusing usecallback might lead to unnecessary complexity in your codebase.

comparing with usememo: use callback and usememo are similar in that they both memoize values. the difference is that
use callback for functions and usememo for non function values.

//usereducer hook
usereducer hook is a built in hook that allows yout to manage complex state logic in more organized and predictable manner,
especially when dealing with state transitions that involve mulitple actions. it is an alternative to using the useState
hook when the state management becomes more intricate.
the primary use cases for usereducer are:
state and dispatch: the usereducer hook takes two arguments a reducer functions and an initial state. it returns an array
with two elements. the current state and a dispatch function. the dispatch function is used to send actions to the reducer
,which then processes the action and returns a new state.

reducer functions: the reducer function is responsible for handling the state transitions based on the actions dispatched.it take two arguments. the current state and the actions being dispatched.it returns the new state based on the action's logic.
actions: it are objects that describe what kind of state change you want to perform they typically have a type property
to identify the actions type, and additional data as needed.

//usecontext hook
it is a react hook that provides a way to access the value of a context directly in functional components without having to explicitly pass down props through intermediary
components. the usecontext hook is part of the context api which is a mechanism in rect that allows data to be passed through the component tree without having to pass props down manually at every level.
the primary use cases for useContext are:
theme switching: you can useContext to manage a theme throughout your app instead of passing
the theme prop to every component that needs it you can define a themecontext and use
usecontext to access the current theme directly in components.

authentication: managing user authentication state across your app is a common use case
for usecontext. you can create an authcontext to store the user authentication status and details. components can then use usecontext to acces this information and conditionally
render ui components based on the user authentication status:

localization:if your app supports mulitple language, you can use usecontext to provide language/locale information to various components without passing props down the component tree.

global state management. while more complex than just using usestate, usecontext can be used
to manage global state that need to be accessed and modified from multple components. its often used in conjuction with the usereducer hook to create a predictable state management solution similar to libraries like redux.

redux replacement: for small application, you might choose to use usecontext and the useeducer hook as simpler alternative to redux for managing state.

dependency injection: you can use usecontext to provide services or dependencies to components for eg: you might havea configcontext that provides configuraiton.

custom theming: if your app require custom theming based on user preference , you can use usecontext to provide the theme setting to different parts of the app.

caching and data fetching: you can use usecontext to manage cached data or api responses that mutiple components might need access to

//react context api
context api is a way to manage state and share data throughout your component tree without the need to pass props manually at every level. it's particularly useful for passing down global data or application wide settings.
the primary use cases of contextapi are:
provider and consumer relationship
the context api revolves around the concept of a provider component and consumer components.
the provider component is used to wrap a portion of your component tree, making the data available to all nested components.
creating a context:
create a context using the createcontext function from the react module. eg:
const mycontext = react.createContext(defaultvalue);

provider components:
wrap components with the provider to give them access to the context data.
pass the data you want to share as a prop to the provider.

consuming the context: use the consumer component or the usecontext hok to access the context data.

default value:
the createcontext function accepts a default value as an argument. this value is used when a component doest have a matching provider in its ancestor tree.
eg: const myContext = react.createContext(default value);

updating context data:
context data can be updated by modifying the state within the provider component when the context data changes, all component consuming that context will re-render.

performance optimization: tp prevent unnecessary re-renders, you can use the react.memo high order component or the usememo hook to wrap components that consume context data.

mulitple contexts:
you can have multiple context providers and consumers in the same component tree.each context works independently and components can consume data from multiple contexts.
caveats and considerations:
context is best suited for data that is ruly global or needs to be accessed by multiple components at different levels.
avoiding using context for fine grained state that is only needed within a few closely related components.

// useLayoutEffect
it is a react hook that is similr to the useEffect hook, but it fires synchronously after all dom mutations. its useful when you need to perform some actions that rely on the most up to date dom layout and before the browser paints to the screen.

the primary use cases for useLayoutEffect are:
useLayoutEffect is a react hook that used to perform side effects after renderin and before the browser layout and paint process.
its very similar to the useeffect hook but fires synchronously after all do mutations have been processed,
whereas useeffect fires asynchronous after rendering.

its often used for actins that depend on accurate dom measurements or that need to update the ui before its visually presented to the user.

//useSyncExternalStore
it is a react hook that lets you subscrive to an external store.
const snapshot = useSyncExternalStore(subscribe, getSnapShot, getServerSnapshot?);
the primary use cases for useSyncExternalStore are:
call useSyncExternalStore at the top level of your component to read a value from an external data store,
it returns the snapshot of the data in the store. you need to pass two functions as arguements:
the subscribe function should subscribe to the store and return a function that unsubscribes.
the getSnapShot function should read a snapshot of the data from the store.
usage:
subscribing to an external store.
most of your react components will only read data from their props, state, and context, however sometimes a component need to read some data from store outside of react that changes over time this includes.
third party state managment libraries that hold state outside of react.
browser apis that expose a mutuable value and events to subscribe to its changes.
const snapshot = useSyncExternalStore(subscribe, getSnapShot,getServerSnapshot?);
callback function(subscribe), getSnapShot(current value store), getServerSnapshot return server rendering

//useTransition Hook
it a react hook that lets you update the state without blocking the UI.
const[isPending, StartTransition] = useTransition()

the primary use cases for useTransition are:
call useTransition at the top level of your component to mark some state updates sas transitions.
useTransition returns an array with exactly two items.
the isPending flag that tells you whether there is a pending tansition.
the startTransition function that lets you mark a state update as transition.

//use DeferredValue Hook
it is a react hook that lets you defer updating a part of the UI.
const deferredValue = useDeferredValue(value);
the primary use cases for useDeferredValue are:
call useDeferredValue at the top level of your component to get a deferred version of that value.
Deferring re-rendering for a part of the UI.
you can also apply useDeferredValue as a performance optimization.it is useful when a part of your UI is slow to re-render, there's no easy way to optimize it, and you want to prevent it from blocking the rest of the UI.

react UseId Hook

useId is a react hook for generating unique id's that can be passed to accessiblity attributes.
const id = useId()

the primary use cases for useId are:
call useId at the top level of your component to generate a unique id:
useId returns a unique ID string associated with this particulary useId call in this particular component.
if you need to give Ids to multiple related elements, you can call useId to generate a shared prefix for them.
https://youtu.be/rPPr5bqPYr0?list=PLdPwRNmUlk0lybMtRRF5xrvFd1UEo6UAR&t=198
